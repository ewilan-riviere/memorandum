# Testing API Calls

Unless youâ€™re working with a simple static website, your Vue app is likely making API calls from within certain components. In this lesson, weâ€™ll look at how we can test these kinds of data-fetching components.

The first thing to understand about testing components that make API calls is that we donâ€™t want to be making real calls out to our backend. Doing so would couple our unit tests to the backend. This becomes an issue when we want to execute our unit tests in [Continuous Integration](https://en.wikipedia.org/wiki/Continuous_integration). Real backends can also be unreliable, and we need our tests to behave predictably.

We want our tests to be fast and reliable, and we can achieve that by _mocking_ our API calls and simply focusing on the inputs and outputs of the component weâ€™re testing. In this lesson weâ€™ll be using [axios](https://github.com/axios/axios), the popular promise-based HTTP client, to make our calls. This means weâ€™ll have to mock axiosâ€™ behavior, which weâ€™ll do in a moment. But first letâ€™s take a look at the starting code.

---

## The Starting Code

For the sake of simplicity, instead of plugging into a full backend, weâ€™re using [json-server](https://github.com/typicode/json-server), which gives us a fake REST API. If this library is new to you, we taught it over in our Real World Vue course. What you need to know for this lesson is: our **db.json** file is our database, and json-server can fetch data from it.

Our simple db has one endpoint: â€œmessageâ€, and this is the data weâ€™ll be fetching.

**ðŸ“„ db.json**

```json
{
"message": { "text": "Hello from the db!" }
}
```

In our project, Iâ€™ve also added an API service layer, which will handle the actual API calls.

ðŸ“**services/ðŸ“„axios.js**

```jsx
import axios from 'axios'

export function getMessage() {
return axios.get('http://localhost:3000/message').then(response => {
return response.data
})
}
```

As you can see, weâ€™ve imported axios and we are exporting the `getMessage()` function, which makes a `get` request to our endpoint: `http://localhost:3000/message`, then weâ€™re returning the data from the response.

Now that we understand how and where weâ€™re pulling our data from, we can look at the component that triggers this API call, and displays the returned data.

**ðŸ“„MessageDisplay.vue**

```html
<template>
    <div>
        <p v-if="error" data-testid="message-error">{{ error }}</p>
        <p v-else data-testid="message">{{ message.text }}</p>
    </div>
</template>

<script>
    import {
        getMessage
    } from '@/services/axios.js'

    export default {
        data() {
            return {
                message: {},
                error: null
            }
        },

        async created() {
            try {
                this.message = await getMessage()
            } catch (err) {
                this.error = 'Oops! Something went wrong.'
            }
        }
    }
</script>
```

In the `<script>
    ` section, weâ€™ve imported the `
    getMessage` function from our **axios.js** file, and when our component is `
    created`, it calls `
    getMessage` using `
    async ` / `
    await ` since axios is asynchronous and we need to _wait_ for the promise it returns to resolve. When it resolves, weâ€™re setting our componentâ€™s local `
    message` data equal to the resolved value, which gets displayed in the template.

Weâ€™re also wrapping the `
    getMessage` call with `
    try ` in order to `
    catch ` errors that might happen, and if one does occur, weâ€™re setting our local `
    error` data accordingly and displaying that error.

---

## Inputs & Outputs

Looking at the **MessageDisplay.vue** component, what are the inputs and outputs that weâ€™ll need to consider when writing our test?

Well, we know that the response from the `
    getMessage` call is our input, and we have two possible outputs:

1.  The call happens successfully and the message is displayed
2.  The call fails and the error is displayed

So in our test file, weâ€™ll need to:

1.  Mock a successful call to `
    getMessage`, checking that the `
    message` is displayed
    
2.  Mock a failed call to `
    getMessage`, checking that the `
    error` is displayed
    

Letâ€™s get started with learning how to mock axios.

---

## Mocking Axios

Letâ€™s scaffold the test block, import the component weâ€™re testing, mount it, and use comments to piece apart what our tests need to be doing.

**ðŸ“„ MessageDisplay.spec.js**

`
    ``
    jsx
    import MessageDisplay from '@/components/MessageDisplay'
    import {
        mount
    } from '@vue/test-utils'

    describe('MessageDisplay', () => {
        it('Calls getMessage and displays message', async () => {
            // mock the API call
            const wrapper = mount(MessageDisplay)
            // wait for promise to resolve
            // check that call happened once
            // check that component displays message
        })

        it('Displays an error when getMessage call fails', async () => {
            // mock the failed API call
            const wrapper = mount(MessageDisplay)
            // wait for promise to resolve
            // check that call happened once
            // check that component displays error
        })
    })
    ``
    `

So letâ€™s fill out these tests, one by one. Looking at the test where it â€œCalls getMessage and displays messageâ€, our first step is to mock axios. Again, when testing components that make API calls, we donâ€™t want to be making actual calls out to our database. We can get away with simply _pretending_ we made the call by mocking that behavior, using Jestâ€™s [mock](https://jestjs.io/docs/en/mock-functions.html) function.

In order to mock our API call, weâ€™ll first import the `
    getMessage` function from our **axios.js** file. We can then feed that function to `
    jest.mock()` by passing it the path for where that function lives.

**ðŸ“„ MessageDisplay.spec.js**

`
    ``
    jsx
    import MessageDisplay from '@/components/MessageDisplay'
    import {
        mount
    } from '@vue/test-utils'
    import {
        getMessage
    } from '@/services/axios'

    jest.mock('@/services/axios')

        ...
    })
    ``
    `

You can think of `
    jest.mock` as saying: â€œIâ€™ll take your `
    getMessage` function, and in return Iâ€™ll give you a _mocked_ `
    getMessage` function.â€ Now, when we call `
    getMessage` within our tests, weâ€™re actually calling the _mocked_ version of that function, not the actual one.

So letâ€™s call our newly mocked `
    getMessage` function from within our first test.

**ðŸ“„ MessageDisplay.spec.js**

`
    ``
    jsx
    import MessageDisplay from '@/components/MessageDisplay'
    import {
        mount
    } from '@vue/test-utils'
    import {
        getMessage
    } from '@/services/axios'

    jest.mock('@/services/axios')

    describe('MessageDisplay', () => {
        it('Calls getMessage and displays message', async () => {
            const mockMessage = 'Hello from the db'
            getMessage.mockResolvedValueOnce({
                text: mockMessage
            }) // calling our mocked get request
            const wrapper = mount(MessageDisplay)
            // wait for promise to resolve
            // check that call happened once
            // check that component displays message
        })
    })
    ``
    `

By using jestâ€™s ` < a href = "https://jestjs.io/docs/en/mock-function-api.html#mockfnmockresolvedvalueoncevalue"
    target = "blank" > mockResolvedValueOnce() < /a>` method, weâ€™re doing exactly what the method name suggests: pretending to make the API call and returning a mocked value for the call to resolve with. As its argument, this method takes in the value we want this mocked function to resolve with. In other words, this is where we put a stand-in for what the request shouldâ€™ve returned. So weâ€™ll pass in `{ text: mockMessage }` to replicate what the server would respond with.

    As you can see, weâ€™ re using `async`
    like we have in previous tests, because axios(and our _mocked_ axios call) is asynchronous.This means that before we write any assertions, weâ€™ ll need to make sure that the promise that our mocked call returns gets resolved.Otherwise, our tests would run before the promise is resolved, and fail.

        -- -

        # # Awaiting Promises

    When figuring out where to `await` in our test, we have to think back to how `getMessage`
    is being called in the component weâ€™ re testing.Remember, itâ€™ s being called on the componentâ€™ s `created`
    lifecycle hook ?

        **
        ðŸ“„MessageDisplay.vue **

        ``
    `jsx
  async created() {
    try {
      this.message = await getMessage()
    } catch (err) {
      this.error = 'Oops! Something went wrong.'
    }
  }
`
    ``

    Since vue - test - utils doesnâ€™ t have access to the internals of promises that are enqueued by the `created`
    lifecycle hook, we canâ€™ t really tap into anything to `await`
    for that promise.So the solution here is to use a third - party library called[flush - promises](https: //www.npmjs.com/package/flush-promises) which allows us toâ€”wellâ€”flush the promises, ensuring theyâ€™re all resolved prior to running our assertions.

            Once weâ€™ ve installed the library with `npm i flush-promises --save-dev`, weâ€™ ll
            import it into our testing file and `await`
            the flushing of the promises.

            **
            ðŸ“„MessageDisplay.spec.js **

            ``
            `jsx
import MessageDisplay from '@/components/MessageDisplay'
import { mount } from '@vue/test-utils'
import { getMessage } from '@/services/axios'
import flushPromises from 'flush-promises'

jest.mock('@/services/axios')

describe('MessageDisplay', () => {
  it('Calls getMessage once and displays message', async () => {
    const mockMessage = 'Hello from the db' 
    getMessage.mockResolvedValueOnce({ text: mockMessage })
    const wrapper = mount(MessageDisplay)

    await flushPromises()
    // check that call happened once
    // check that component displays message
  })
})
`
            ``

            Now that weâ€™ ve ensured promises will be resolved before our assertions are run, we can write those assertions.

            -- -

            # # Our Assertions

            First up, weâ€™ ll want to make sure our API call is only happening once.

            **
            ðŸ“„MessageDisplay.spec.js **

            ``
            `jsx
  it('Calls getMessage once and displays message', async () => {
    const mockMessage = 'Hello from the db'
    getMessage.mockResolvedValueOnce(mockMessage)
    const wrapper = mount(MessageDisplay)

    await flushPromises()
    expect(getMessage).toHaveBeenCalledTimes(1) // check that call happened once
    // check that component displays message
  })
`
            ``

            Weâ€™ re simply running the method `.toHaveBeenCalledTimes()`
            and passing in the number of times we expect `getMessage`
            to have been called: `1`.Now weâ€™ ve ensured that we arenâ€™ t accidentally hitting our server more times than we should be.

            -- -

            Next up, we need to check that our component is displaying the message it received from our `getMessage`
            request.In the ** MessageDisplay ** componentâ€™ s template, the `p`
            tag that displays the message has an id to be used
            for tests: `data-testid="message"`

            **
            ðŸ“„MessageDisplay.vue **

            ``
            `html
<template>
  <p v-if="error" data-testid="message-error">{{ error }}</p>
  <p v-else data-testid="message">{{ message }}</p>
</template>
`
            ``

            We learned about these testing ids in the previous lesson.Weâ€™ ll use that id to `find`
            the element, then assert that its text content should be equal to the value our mocked `getMessage`
            request resolved with: `mockMessage`

            **
            ðŸ“„MessageDisplay.spec.js **

            ``
            `jsx
  it('Calls getMessage once and displays message', async () => {
    const mockMessage = 'Hello from the db' 
    getMessage.mockResolvedValueOnce({ text: mockMessage })
    const wrapper = mount(MessageDisplay)

    await flushPromises()
    expect(getMessage).toHaveBeenCalledTimes(1)
    const message = wrapper.find('[data-testid="message"]').text()
    expect(message).toEqual(mockMessage)
  })
`
            ``

            If we run `npm run test:unit` in the terminal, weâ€™ ll see our newly written test is passing!We can now move on to our second test, where weâ€™ ll mock a _failed_ `getMessage`
            request and check that our component is displaying the error.

            -- -

            # # Mocking a failed request

            The first step, of mocking the failed API call, is very similar to our first test.

            **
            ðŸ“„MessageDisplay.spec.js **

            ``
            `jsx
  it('Displays an error when getMessage call fails', async () => {
    const mockError = 'Oops! Something went wrong.'
    getMessage.mockRejectedValueOnce(mockError)
    const wrapper = mount(MessageDisplay)

    await flushPromises()
    // check that call happened once
    // check that component displays error
  })
`
            ``

            Notice how weâ€™ re using `mockRejectedValueOnce`
            to simulate the failed get request, and weâ€™ re passing it the `mockError`
            for it to resolve with.

            After awaiting the flushing of the promises, we can then check that the call only happened once and verify that our componentâ€™ s template is displaying the expected `mockError`.

            **
            ðŸ“„MessageDisplay.spec.js **

            ``
            `jsx
  it('Displays an error when getMessage call fails', async () => {
    const mockError = 'Oops! Something went wrong.'
    getMessage.mockRejectedValueOnce(mockError)
    const wrapper = mount(MessageDisplay)

    await flushPromises()
    expect(getMessage).toHaveBeenCalledTimes(1)
    const displayedError = wrapper.find('[data-testid="message-error"]').text()
    expect(displayedError).toEqual(mockError)
  })
`
            ``

            Just like our first test, weâ€™ re using `.toHaveBeenCalledTimes(1)`
            to make sure weâ€™ re not making the API call more than we should be, and weâ€™ re finding the element that displays the error message and checking its text content against the `mockError`
            that our mocked failed request returned.

            Now
            if we run these tests, what happens ? The test is failing :

            **
            Expected number of calls: 1 Received number of calls: 2 **

            Hmmâ€¦ whatâ€™ s happening here ? Well, in our first test, `getMessage`
            was called, and then it gets called again in our second test.We havenâ€™ t done anything to clear out our mocked `getMessage`
            function before running the second test.Fortunately, the fix is quite simple.

            -- -

            # # Clear All Mocks

            Below where weâ€™ re creating our jest mock, we can add the solution, clearing all of our mocks.

            **
            ðŸ“„MessageDisplay.spec.js **

            ``
            `jsx
jest.mock('@/services/axios')
beforeEach(() => {
  jest.clearAllMocks()
})
`
            ``

            Now, `beforeEach`
            test is run, weâ€™ ll make sure the `getMessage`
            mock has been cleared, which will reset the number of times itâ€™ s been called back to 0.

            Now, when we run our tests, theyâ€™ re all passing.Great work!

            -- -

            # # The Full Code

            **
            ðŸ“„MessageDisplay.spec.js **

            ``
            `jsx
import MessageDisplay from '@/components/MessageDisplay'
import { mount } from '@vue/test-utils'
import { getMessage } from '@/services/axios'
import flushPromises from 'flush-promises'

jest.mock('@/services/axios')
beforeEach(() => {
  jest.clearAllMocks()
})

describe('MessageDisplay', () => {
  it('Calls getMessage and displays message', async () => {
    const mockMessage = 'Hello from the db' 
    getMessage.mockResolvedValueOnce({ text: mockMessage })
    const wrapper = mount(MessageDisplay)

    await flushPromises()
    expect(getMessage).toHaveBeenCalledTimes(1)

    const message = wrapper.find('[data-testid="message"]').text()
    expect(message).toEqual(mockMessage)
  })

  it('Displays an error when getMessage call fails', async () => {
    const mockError = 'Oops! Something went wrong.'
    getMessage.mockRejectedValueOnce(mockError)
    const wrapper = mount(MessageDisplay)

    await flushPromises()
    expect(getMessage).toHaveBeenCalledTimes(1)
    const displayedError = wrapper.find('[data-testid="message-error"]').text()
    expect(displayedError).toEqual(mockError)
  })
})
`
            ``

            -- -

            # # Letâ€™ s ReVue

            Weâ€™ ve learned that when testing API calls, the same essential rules apply : focus on the componentâ€™ s inputs(the requestâ€™ s response) and outputs(the message or error thatâ€™ s displayed),
            while being conscious of avoiding tight coupling between the test and the implementation details of the component(finding the element by its testing id versus finding it by its element type,
                for example).We also learned how to use jest to mock our calls and the third party library flush - promises to await asynchronous behavior in our lifecycle hooks.

            In the next lesson, weâ€™ ll learn what the heck a stub is and how it can help us test parent components.